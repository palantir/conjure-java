package com.palantir.another;

import com.google.common.collect.ImmutableList;
import com.google.common.reflect.TypeToken;
import com.palantir.conjure.java.undertow.lib.BinaryResponseBody;
import com.palantir.conjure.java.undertow.lib.Deserializer;
import com.palantir.conjure.java.undertow.lib.Endpoint;
import com.palantir.conjure.java.undertow.lib.Serializer;
import com.palantir.conjure.java.undertow.lib.UndertowRuntime;
import com.palantir.conjure.java.undertow.lib.UndertowService;
import com.palantir.product.AliasedString;
import com.palantir.product.CreateDatasetRequest;
import com.palantir.product.NestedAliasedBinary;
import com.palantir.product.datasets.BackingFileSystem;
import com.palantir.product.datasets.Dataset;
import com.palantir.ri.ResourceIdentifier;
import com.palantir.tokens.auth.AuthHeader;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HeaderMap;
import io.undertow.util.HttpString;
import io.undertow.util.Methods;
import io.undertow.util.PathTemplateMatch;
import io.undertow.util.StatusCodes;
import java.io.IOException;
import java.io.InputStream;
import java.util.Deque;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.Set;
import javax.annotation.Generated;

@Generated("com.palantir.conjure.java.services.UndertowServiceHandlerGenerator")
public final class TestServiceEndpoints implements UndertowService {
    private final TestService delegate;

    private TestServiceEndpoints(TestService delegate) {
        this.delegate = delegate;
    }

    public static UndertowService of(TestService delegate) {
        return new TestServiceEndpoints(delegate);
    }

    @Override
    public List<Endpoint> endpoints(UndertowRuntime runtime) {
        return ImmutableList.of(
                new GetFileSystemsEndpoint(runtime, delegate),
                new CreateDatasetEndpoint(runtime, delegate),
                new GetDatasetEndpoint(runtime, delegate),
                new GetRawDataEndpoint(runtime, delegate),
                new GetAliasedRawDataEndpoint(runtime, delegate),
                new MaybeGetRawDataEndpoint(runtime, delegate),
                new GetAliasedStringEndpoint(runtime, delegate),
                new UploadRawDataEndpoint(runtime, delegate),
                new UploadAliasedRawDataEndpoint(runtime, delegate),
                new GetBranchesEndpoint(runtime, delegate),
                new GetBranchesDeprecatedEndpoint(runtime, delegate),
                new ResolveBranchEndpoint(runtime, delegate),
                new TestParamEndpoint(runtime, delegate),
                new TestQueryParamsEndpoint(runtime, delegate),
                new TestNoResponseQueryParamsEndpoint(runtime, delegate),
                new TestBooleanEndpoint(runtime, delegate),
                new TestDoubleEndpoint(runtime, delegate),
                new TestIntegerEndpoint(runtime, delegate),
                new TestPostOptionalEndpoint(runtime, delegate),
                new TestOptionalIntegerAndDoubleEndpoint(runtime, delegate));
    }

    private static final class GetFileSystemsEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<Map<String, BackingFileSystem>> serializer;

        GetFileSystemsEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer =
                    runtime.serde().serializer(new TypeToken<Map<String, BackingFileSystem>>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, BackingFileSystem> result = delegate.getFileSystems(authHeader);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/fileSystems";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "getFileSystems";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class CreateDatasetEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Deserializer<CreateDatasetRequest> deserializer;

        private final Serializer<Dataset> serializer;

        CreateDatasetEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.deserializer =
                    runtime.serde().deserializer(new TypeToken<CreateDatasetRequest>() {});
            this.serializer = runtime.serde().serializer(new TypeToken<Dataset>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            CreateDatasetRequest request = deserializer.deserialize(exchange);
            HeaderMap headerParams = exchange.getRequestHeaders();
            String testHeaderArg =
                    runtime.serde().plain().deserializeString(headerParams.get("Test-Header"));
            Dataset result = delegate.createDataset(authHeader, testHeaderArg, request);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.POST;
        }

        @Override
        public String template() {
            return "/catalog/datasets";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "createDataset";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class GetDatasetEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<Optional<Dataset>> serializer;

        GetDatasetEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<Optional<Dataset>>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, String> pathParams =
                    exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY).getParameters();
            ResourceIdentifier datasetRid =
                    runtime.serde().plain().deserializeRid(pathParams.get("datasetRid"));
            Optional<Dataset> result = delegate.getDataset(authHeader, datasetRid);
            if (result.isPresent()) {
                serializer.serialize(result, exchange);
            } else {
                exchange.setStatusCode(StatusCodes.NO_CONTENT);
            }
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/datasets/{datasetRid}";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "getDataset";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class GetRawDataEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        GetRawDataEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, String> pathParams =
                    exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY).getParameters();
            ResourceIdentifier datasetRid =
                    runtime.serde().plain().deserializeRid(pathParams.get("datasetRid"));
            BinaryResponseBody result = delegate.getRawData(authHeader, datasetRid);
            runtime.serde().serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/datasets/{datasetRid}/raw";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "getRawData";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class GetAliasedRawDataEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<NestedAliasedBinary> serializer;

        GetAliasedRawDataEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<NestedAliasedBinary>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, String> pathParams =
                    exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY).getParameters();
            ResourceIdentifier datasetRid =
                    runtime.serde().plain().deserializeRid(pathParams.get("datasetRid"));
            NestedAliasedBinary result = delegate.getAliasedRawData(authHeader, datasetRid);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/datasets/{datasetRid}/raw-aliased";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "getAliasedRawData";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class MaybeGetRawDataEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        MaybeGetRawDataEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, String> pathParams =
                    exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY).getParameters();
            ResourceIdentifier datasetRid =
                    runtime.serde().plain().deserializeRid(pathParams.get("datasetRid"));
            Optional<BinaryResponseBody> result = delegate.maybeGetRawData(authHeader, datasetRid);
            if (result.isPresent()) {
                runtime.serde().serialize(result.get(), exchange);
            } else {
                exchange.setStatusCode(StatusCodes.NO_CONTENT);
            }
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/datasets/{datasetRid}/raw-maybe";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "maybeGetRawData";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class GetAliasedStringEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<AliasedString> serializer;

        GetAliasedStringEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<AliasedString>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, String> pathParams =
                    exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY).getParameters();
            ResourceIdentifier datasetRid =
                    runtime.serde().plain().deserializeRid(pathParams.get("datasetRid"));
            AliasedString result = delegate.getAliasedString(authHeader, datasetRid);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/datasets/{datasetRid}/string-aliased";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "getAliasedString";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class UploadRawDataEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        UploadRawDataEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            InputStream input = runtime.serde().deserializeInputStream(exchange);
            delegate.uploadRawData(authHeader, input);
            exchange.setStatusCode(StatusCodes.NO_CONTENT);
        }

        @Override
        public HttpString method() {
            return Methods.POST;
        }

        @Override
        public String template() {
            return "/catalog/datasets/upload-raw";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "uploadRawData";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class UploadAliasedRawDataEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Deserializer<NestedAliasedBinary> deserializer;

        UploadAliasedRawDataEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.deserializer =
                    runtime.serde().deserializer(new TypeToken<NestedAliasedBinary>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            NestedAliasedBinary input = deserializer.deserialize(exchange);
            delegate.uploadAliasedRawData(authHeader, input);
            exchange.setStatusCode(StatusCodes.NO_CONTENT);
        }

        @Override
        public HttpString method() {
            return Methods.POST;
        }

        @Override
        public String template() {
            return "/catalog/datasets/upload-raw-aliased";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "uploadAliasedRawData";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class GetBranchesEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<Set<String>> serializer;

        GetBranchesEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<Set<String>>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, String> pathParams =
                    exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY).getParameters();
            ResourceIdentifier datasetRid =
                    runtime.serde().plain().deserializeRid(pathParams.get("datasetRid"));
            Set<String> result = delegate.getBranches(authHeader, datasetRid);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/datasets/{datasetRid}/branches";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "getBranches";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class GetBranchesDeprecatedEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<Set<String>> serializer;

        GetBranchesDeprecatedEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<Set<String>>() {});
        }

        @Override
        @SuppressWarnings("deprecation")
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, String> pathParams =
                    exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY).getParameters();
            ResourceIdentifier datasetRid =
                    runtime.serde().plain().deserializeRid(pathParams.get("datasetRid"));
            Set<String> result = delegate.getBranchesDeprecated(authHeader, datasetRid);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/datasets/{datasetRid}/branchesDeprecated";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "getBranchesDeprecated";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class ResolveBranchEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<Optional<String>> serializer;

        ResolveBranchEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<Optional<String>>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, String> pathParams =
                    exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY).getParameters();
            ResourceIdentifier datasetRid =
                    runtime.serde().plain().deserializeRid(pathParams.get("datasetRid"));
            String branch = runtime.serde().plain().deserializeString(pathParams.get("branch"));
            Optional<String> result = delegate.resolveBranch(authHeader, datasetRid, branch);
            if (result.isPresent()) {
                serializer.serialize(result, exchange);
            } else {
                exchange.setStatusCode(StatusCodes.NO_CONTENT);
            }
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/datasets/{datasetRid}/branches/{branch:.+}/resolve";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "resolveBranch";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class TestParamEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<Optional<String>> serializer;

        TestParamEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<Optional<String>>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, String> pathParams =
                    exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY).getParameters();
            ResourceIdentifier datasetRid =
                    runtime.serde().plain().deserializeRid(pathParams.get("datasetRid"));
            Optional<String> result = delegate.testParam(authHeader, datasetRid);
            if (result.isPresent()) {
                serializer.serialize(result, exchange);
            } else {
                exchange.setStatusCode(StatusCodes.NO_CONTENT);
            }
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/datasets/{datasetRid}/testParam";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "testParam";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class TestQueryParamsEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Deserializer<String> deserializer;

        private final Serializer<Integer> serializer;

        TestQueryParamsEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.deserializer = runtime.serde().deserializer(new TypeToken<String>() {});
            this.serializer = runtime.serde().serializer(new TypeToken<Integer>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            String query = deserializer.deserialize(exchange);
            Map<String, Deque<String>> queryParams = exchange.getQueryParameters();
            ResourceIdentifier something =
                    runtime.serde().plain().deserializeRid(queryParams.get("different"));
            Optional<ResourceIdentifier> optionalMiddle =
                    runtime.serde()
                            .plain()
                            .deserializeOptionalRid(queryParams.get("optionalMiddle"));
            ResourceIdentifier implicit =
                    runtime.serde().plain().deserializeRid(queryParams.get("implicit"));
            Set<String> setEnd =
                    runtime.serde().plain().deserializeStringSet(queryParams.get("setEnd"));
            Optional<ResourceIdentifier> optionalEnd =
                    runtime.serde().plain().deserializeOptionalRid(queryParams.get("optionalEnd"));
            int result =
                    delegate.testQueryParams(
                            authHeader,
                            something,
                            implicit,
                            optionalMiddle,
                            setEnd,
                            optionalEnd,
                            query);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.POST;
        }

        @Override
        public String template() {
            return "/catalog/test-query-params";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "testQueryParams";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class TestNoResponseQueryParamsEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Deserializer<String> deserializer;

        TestNoResponseQueryParamsEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.deserializer = runtime.serde().deserializer(new TypeToken<String>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            String query = deserializer.deserialize(exchange);
            Map<String, Deque<String>> queryParams = exchange.getQueryParameters();
            ResourceIdentifier something =
                    runtime.serde().plain().deserializeRid(queryParams.get("different"));
            Optional<ResourceIdentifier> optionalMiddle =
                    runtime.serde()
                            .plain()
                            .deserializeOptionalRid(queryParams.get("optionalMiddle"));
            ResourceIdentifier implicit =
                    runtime.serde().plain().deserializeRid(queryParams.get("implicit"));
            Set<String> setEnd =
                    runtime.serde().plain().deserializeStringSet(queryParams.get("setEnd"));
            Optional<ResourceIdentifier> optionalEnd =
                    runtime.serde().plain().deserializeOptionalRid(queryParams.get("optionalEnd"));
            delegate.testNoResponseQueryParams(
                    authHeader, something, implicit, optionalMiddle, setEnd, optionalEnd, query);
            exchange.setStatusCode(StatusCodes.NO_CONTENT);
        }

        @Override
        public HttpString method() {
            return Methods.POST;
        }

        @Override
        public String template() {
            return "/catalog/test-no-response-query-params";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "testNoResponseQueryParams";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class TestBooleanEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<Boolean> serializer;

        TestBooleanEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<Boolean>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            boolean result = delegate.testBoolean(authHeader);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/boolean";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "testBoolean";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class TestDoubleEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<Double> serializer;

        TestDoubleEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<Double>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            double result = delegate.testDouble(authHeader);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/double";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "testDouble";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class TestIntegerEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Serializer<Integer> serializer;

        TestIntegerEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.serializer = runtime.serde().serializer(new TypeToken<Integer>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            int result = delegate.testInteger(authHeader);
            serializer.serialize(result, exchange);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/integer";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "testInteger";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class TestPostOptionalEndpoint implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        private final Deserializer<Optional<String>> deserializer;

        private final Serializer<Optional<String>> serializer;

        TestPostOptionalEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
            this.deserializer = runtime.serde().deserializer(new TypeToken<Optional<String>>() {});
            this.serializer = runtime.serde().serializer(new TypeToken<Optional<String>>() {});
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Optional<String> maybeString = deserializer.deserialize(exchange);
            Optional<String> result = delegate.testPostOptional(authHeader, maybeString);
            if (result.isPresent()) {
                serializer.serialize(result, exchange);
            } else {
                exchange.setStatusCode(StatusCodes.NO_CONTENT);
            }
        }

        @Override
        public HttpString method() {
            return Methods.POST;
        }

        @Override
        public String template() {
            return "/catalog/optional";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "testPostOptional";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }

    private static final class TestOptionalIntegerAndDoubleEndpoint
            implements HttpHandler, Endpoint {
        private final UndertowRuntime runtime;

        private final TestService delegate;

        TestOptionalIntegerAndDoubleEndpoint(UndertowRuntime runtime, TestService delegate) {
            this.runtime = runtime;
            this.delegate = delegate;
        }

        @Override
        public void handleRequest(HttpServerExchange exchange) throws IOException {
            AuthHeader authHeader = runtime.auth().header(exchange);
            Map<String, Deque<String>> queryParams = exchange.getQueryParameters();
            OptionalInt maybeInteger =
                    runtime.serde()
                            .plain()
                            .deserializeOptionalInteger(queryParams.get("maybeInteger"));
            OptionalDouble maybeDouble =
                    runtime.serde()
                            .plain()
                            .deserializeOptionalDouble(queryParams.get("maybeDouble"));
            delegate.testOptionalIntegerAndDouble(authHeader, maybeInteger, maybeDouble);
            exchange.setStatusCode(StatusCodes.NO_CONTENT);
        }

        @Override
        public HttpString method() {
            return Methods.GET;
        }

        @Override
        public String template() {
            return "/catalog/optional-integer-double";
        }

        @Override
        public String serviceName() {
            return "TestService";
        }

        @Override
        public String name() {
            return "testOptionalIntegerAndDouble";
        }

        @Override
        public HttpHandler handler() {
            return this;
        }
    }
}
