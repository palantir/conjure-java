# conjure-undertow-processor generated undertow services

`conjure-undertow-processor` generates Undertow handler for services that can not easily be represented using
[Conjure](https://github.com/palantir/conjure-java).

## Motivation

Historically we have supported Jersey as web server framework, but later migrated to Undertow. Beyond a desire not to
support multiple frameworks, Jersey is problematic for a variety of other reasons and does not align with our long term
technical goals of our Java ecosystem.

Consumers that are still using Jersey should migrate and declare their endpoints using Conjure. However, some
complex services are using features that are tricky to represent or not supported using Conjure. To help these services
migrate away from Jersey, `conjure-undertow-processor` provides a more flexible way of defining your service interface
while still profiting from code generation.

## Getting Started

In your API project, add the following dependencies to your `build.gradle` file (make sure you are using 
[gradle-processors](https://github.com/palantir/gradle-processors)):

```gradle
dependencies {
    implementation 'com.palantir.conjure.java:conjure-undertow-annotations'
    annotationProcessor 'com.palantir.conjure.java:conjure-undertow-processor'
}
```

Next, define your service interface and annotate it using [`conjure-undertow-annotations`](src/main/java/com/palantir/conjure/java/undertow/annotations/Handle.java):

```java
public interface MyService {

    @Handle(method = HttpMethod.POST, path = "/myEndpoint/{pathParam}")
    MyResponse myEndpoint(
            AuthHeader authHeader,
            @Handle.PathParam String pathParam,
            @Handle.QueryParam("queryParam") Optional<String> queryParam,
            @Handle.Body MyBody body);
}
```

During compilation, the `conjure-undertow-processor` will generate a respective `MyServiceEndpoints` handler that can
be used with Undertow similar to handlers [generated by conjure-java](https://github.com/palantir/conjure-java#undertow).

## Features

Check out the [`ExampleService`](../conjure-undertow-processor-example/src/main/java/com/palantir/conjure/java/undertow/example/ExampleService.java) for a concrete example and the [`Handle` class](../conjure-undertow-annotations/src/main/java/com/palantir/conjure/java/undertow/annotations/Handle.java) for a list of available annotations.

### Path and Query Parameters

Path and query parameters can be defined using the `@Handle.PathParam` and `@Handle.QueryParam` annotations:

```java
public interface MyService {

    @Handle(method = HttpMethod.GET, path = "/api/{myParam}/{otherParam}")
    void myEndpoint(
            @Handle.PathParam String myParam,
            @Handle.PathParam String otherParam,
            @Handle.QueryParam("queryParam") String queryParam,
            @Handle.QueryParam("maybeQueryParam") Optional<Boolean> maybeQueryParam);
}
```

### Header and Cookie Values

To access header fields or cookie values, you can use the `@Handle.Header` or `@Handle.Cookie` annotations:

```java
public interface MyService {

    @Handle(method = HttpMethod.GET, path = "/path")
    void myEndpoint(
            @Handle.Header("Foo") String fooHeader,
            @Handle.Cookie("MY_COOKIE") Optional<String> cookieValue);
}
```

When using an HTTP authentication header in the form of `Bearer [token]`, the token can be automatically injected when 
using an [`AuthHeader`](https://github.com/palantir/auth-tokens/blob/develop/auth-tokens/src/main/java/com/palantir/tokens/auth/AuthHeader.java) parameter:

```java
public interface MyService {

    @Handle(method = HttpMethod.GET, path = "/path")
    void myEndpoint(AuthHeader authHeader);
}
```

Similarly, you can access a bearer token from a cookie when using the `@Handle.Cookie` annotation together with the
[`BearerToken`](https://github.com/palantir/auth-tokens/blob/develop/auth-tokens/src/main/java/com/palantir/tokens/auth/BearerToken.java) type which also sets the respective auth state:

```java
public interface MyService {

    @Handle(method = HttpMethod.GET, path = "/path")
    void myEndpoint(@Handle.Cookie("AUTH_TOKEN") BearerToken token);
}
```

### Accessing the Request Context or Server Exchange

If required, you can inject the [`RequestContext`](../conjure-undertow-lib/src/main/java/com/palantir/conjure/java/undertow/lib/RequestContext.java)
or the underlying Undertow [`HttpServerExchange`](https://github.com/undertow-io/undertow/blob/0c5f9128a2390bcf70cc2c1e431968b345df0d84/core/src/main/java/io/undertow/server/HttpServerExchange.java):

```java
public interface MyService {

    @Handle(method = HttpMethod.GET, path = "/path")
    void myEndpoint(HttpServerExchange exchange, RequestContext context);
}
```

### Globbed Path Parameters

the conjure-undertow-processor only supports a restricted version of globbed or wildcard path parameters. Only
as a catch-all at the end of the path when using the `@Handle.PathMultiParam` annotation:

```java
public interface MyService {

    @Handle(method = HttpMethod.GET, path = "/path/{params}")
    void myEndpoint(@Handle.PathMultiParam List<String> params);
}
```

For the above endpoint, the following table shows how various requests are deserilized into wildcard path parameters.

| Request | Params |
| - | - |
| `GET /path/` | `[""]` |
| `GET /path/foo` | `["foo"]` |
| `GET /path/foo/` | `["foo", ""]` |
| `GET /path/foo/bar` | `["foo", "bar"]` |
| `GET /path/foo/bar%2Fbaz` | `["foo", "bar/baz"]` |

### Using Custom Serializer or Deserializers

Per default, conjure-undertow-processor supports decoding parameters for all [plain Conjure types](https://palantir.github.io/conjure/#/docs/spec/wire?id=_7-plain-format)
as well as primitives and types that have either a constructor that accepts a single String argument or a static
method named `valueOf` that accepts a single String argument.

For other parameter types, you can provide a custom decoder by providing an implementation of
either [`ParamDecoder`](src/main/java/com/palantir/conjure/java/undertow/annotations/ParamDecoder.java) or
[`CollectionParamDecoder`](src/main/java/com/palantir/conjure/java/undertow/annotations/CollectionParamDecoder.java).

```java
public interface MyService {

    @Handle(method = HttpMethod.GET, path = "/path")
    void customParam(
            @Handle.QueryParam(value = "query", decoder = MyCollectionParamDecoder.class)
                    Optional<MyType> queryParam);

    enum MyCollectionParamDecoder implements CollectionParamDecoder<Optional<MyType>> {
        INSTANCE;

        @Override
        public Optional<MyType> decode(Collection<String> value) {
            if (value.isEmpty()) {
                return Optional.empty();
            }
            return Optional.of(MyType.from(Iterables.getOnlyElement(value)));
        }
    }
}
```

Similarly, you can provide your own behavior for serializing and deserializing the request body by providing an
implementation of either [`SerializerFactory`](src/main/java/com/palantir/conjure/java/undertow/annotations/SerializerFactory.java)
or [`DeserializerFactory`](src/main/java/com/palantir/conjure/java/undertow/annotations/DeserializerFactory.java):

```java
public interface MyService {

    @Handle(method = HttpMethod.POST, path = "/path", produces = MyResponseSerializerFactory.class)
    MyResponse customParam(@Handle.Body(MyBodyDeserializerFactory.class) MyBody body);

    enum MyBodyDeserializerFactory implements DeserializerFactory<MyBody> {
        INSTANCE;
        // ...
    }

    enum MyResponseSerializerFactory implements SerializerFactory<MyResponse> {
        INSTANCE;
        // ...
    }
}
```
